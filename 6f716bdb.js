const C=Array,G=C.isArray,E=null,B=void 0,W="readwrite",x=indexedDB;let p=E,y=E,D,X;const Z=(e,t)=>{D=e,X=t},F=()=>y||(p?!0:y=(async()=>{const e="id",t={};(await x.databases()).forEach(r=>t[r.name]=r.version);let a=t[D],s=!a,o={};X.split(",").forEach(r=>o[r]=1);let n=x.open(D,a=a||1);if(p=await new Promise(r=>{s&&(n.onupgradeneeded=()=>{const d={keyPath:e};for(const m in o)n.result.createObjectStore(m,d)}),n.onsuccess=()=>r(n.result),n.onerror=()=>r(E)}),p.onclose=H,s||!p)return y=E,!!p;const l=p.objectStoreNames;let i=null;for(let r=l.length-1;r>=0;r-=1){const d=l[r];o[d]?o[d]=2:(i&&i.push(d),!i&&(i=[d]))}const c=Object.keys(o).filter(r=>o[r]<2);return c.length<1?(y=E,!0):(p.close(),n=x.open(D,a+1),p=await new Promise(r=>{n.onupgradeneeded=()=>{const d={keyPath:e},m=n.result;c.forEach(u=>m.createObjectStore(u,d)),i?.forEach(u=>m.deleteObjectStore(u))},n.onsuccess=()=>r(n.result),n.onerror=()=>r(E)}),p.onclose=H,y=E,!!p)})()),H=e=>{!e&&p?.close(),p=E,y=E},U=async(e,t,a)=>{if(!await F())return[];const o=p.transaction(e).objectStore(e),n=t instanceof IDBKeyRange;return await new Promise(l=>{const i=o.getAll(n?t:B,B);i.onsuccess=()=>l(i.result),i.onerror=()=>l([])})},v=async(e,t,a)=>{if(!await F())return!1;const s=G(t)?t:[t];if(!s.length)return!1;const o=p.transaction(e,W),n=o.objectStore(e),l=new Promise(i=>{o.oncomplete=()=>i(!0),o.onerror=()=>i(!1)});if(a)s.forEach(i=>n.put(i));else{const i=new Date().getTime().toString(36),c=(s.length-1).toString(36).length;s.forEach((r,d)=>{r.id||(r.id=`${i}-${d.toString(36).padStart(c,"0")}`),n.put(r)})}return await l},L=async(e,t)=>{if(!await F())return!1;const a=G(t)?t:[t],s=p.transaction(e,W),o=s.objectStore(e),n=new Promise(l=>{s.oncomplete=()=>l(!0),s.onerror=()=>l(!1)});return a.forEach(l=>o.delete(l)),await n},Y=null,R=(1<<22)+2,A="a",b="b",k=0,M=1,V=3,tt=0,S=1,w=2,K=3,O=4,N=Set,T=postMessage,Q=XMLHttpRequest,f=[];let $,I;const et=e=>{let t;const a=e?Object.keys(e).map(s=>(t=e[s])||t===0?`${s}=${encodeURIComponent(t)}`:0).filter(s=>s).join("&"):"";return a&&`?${a}`},z=()=>navigator.storage.getDirectory(),at=e=>e.createSyncAccessHandle(),J=async(e,t)=>{(t||await z()).removeEntry(e).catch(()=>Y)},st=e=>{let t=1024;if(e<t)return`${e}B`;let a=t;return t=1048576,e<t?`${(e/a).toFixed(2)}KB`:(a=t,t=1073741824,e<t?`${(e/a).toFixed(2)}MB`:`${(e/t).toFixed(2)}GB`)},j=(e,t)=>f.filter(a=>a.type===e&&a.data.state===t),_=e=>{const t=j(e,O),a=V-t.length;j(e,K).slice(0,a).forEach(nt)},nt=async e=>{let{type:t,data:a}=e,s=t===k,o=!1;try{await(s?ot(e):rt(e))&&(T({k:s?"d":"g",v:a.id}),o=!0)}catch(n){n===w&&(a.state=n,T({k:s?"c":"f",v:{id:a.id,part:a.part,state:a.state,rate:n}})),o=n===S&&a.state===w}finally{if(o){for(let n=f.length-1;n>=0;--n)if(a.id===f[n].data.id){f.splice(n,1);break}await L(s?A:b,a.id)}else await v(s?A:b,a);delete e.http,_(t)}},ot=async e=>{let t=e.data,a=Math.ceil(t.size/R),s=await t.handle.getFile();t.state=O;let o=[...I,{k:"content-type",v:t.type}];for(;t.part<a&&t.state===O;++t.part){let{part:n}=t,l=n*R;await new Promise((i,c)=>{let r=e.http=new Q;r.responseType="json",r.upload.onprogress=h=>{t.rate=(h.loaded+l)*100/t.size>>0,T({k:"c",v:{id:t.id,rid:t.rid,part:n,state:t.state,rate:t.rate}})},r.onload=()=>{const h=r.response;h.type==="error"?c(w):(!t.rid&&(t.rid=h.data),i())},r.onerror=()=>c(w),r.onabort=()=>c(S);let d=a<2?s:s.slice(l,l+R),m=d.size,u=t.rid?{id:t.rid,part:n+1,length:m}:{name:t.name,size:t.size,length:m,path:t.path};r.open("post",`${$}/file/upload${et(u)}`),o.forEach(h=>r.setRequestHeader(h.k,h.v)),r.send(d)}),n<a-1&&t.state!==w&&await v(A,t,!0)}return t.part===a},rt=async e=>{let t=e.data,a=Math.ceil(t.size/R),{id:s}=t,o={create:!0},n=await z(),i=await(await n.getDirectoryHandle("a",o)).getFileHandle(s,o),c=t.part<a?await at(i):Y;for(t.state=O;t.part<a&&t.state===O;++t.part){let{part:r}=t,d=r*R,m=new Promise((u,h)=>{let g=e.http=new Q;g.responseType="arraybuffer",g.onprogress=P=>{t.rate=(P.loaded+d)*100/t.size>>0,T({k:"f",v:{id:t.id,part:r,state:t.state,rate:t.rate}})},g.onload=()=>{g.status===206?u(g.response):h(w)},g.onerror=()=>h(w),g.onabort=()=>h(S),g.open("post",`${$}/file/download`),I.forEach(P=>g.setRequestHeader(P.k,P.v)),g.send(JSON.stringify({id:s,part:r+1}))});try{let u=await m;c.write(u,{at:d}),c.flush(),r<a-1&&t.state!==w&&await v(b,t,!0)}catch(u){throw u===S&&t.state===w&&J(t.id,n),c.close(),u}}return c?.close(),t.part>=a},q=(e,t)=>{let a=new N(e.filter(s=>s.state===S).map(s=>s.id));for(let s=f.length-1;s>=0;--s){let o=f[s],n=o.data;a.has(n.id)&&(n.state=S,o.http?.abort(),f.splice(s,1))}f.push(...e.filter(s=>s.state===K).map(s=>({type:t,data:s}))),_(t)},it={a({auth:e,url:t}){I=e,$=t,Promise.all([U(A),U(b)]).then(a=>{a.forEach(s=>s.forEach(o=>o.state=S)),T({k:"a",v:a})})},async b(e){let t=new C(e.length),a=-1;for(let s of e){let o=await s.getFile(),n=o.size,l=o.name,i=l.lastIndexOf(".");t[++a]={name:l,part:0,size:n,path:"/",state:tt,type:o.type||"application/octet-stream",handle:s,rate:0,_size:st(n),_type:i>0?l.slice(i+1):"unknown"}}await v(A,t),T({k:"b",v:t})},c(e){q(e,k)},d(e){let t=new N(e),a=new N,s=f.map(o=>o);for(let o=s.length-1;o>=0;--o){let{http:n,data:l}=s[o],{id:i,rid:c}=l;t.has(i)&&(l.state=w,n?.abort(),f.splice(o,1),c&&a.add(c))}a.size>0&&T({k:"d",v:[...a]}),L(A,e),_(k)},e(e){v(b,e)},f(e){q(e,M)},g(e){let t=new N(e);for(let a=f.length-1;a>=0;--a){let{http:s,data:o}=f[a];t.has(o.id)&&(o.state=w,s?.abort(),f.splice(a,1))}z().then(a=>e.forEach(s=>J(s,a))),L(b,e),_(M)}};onmessage=({data:e})=>{it[e.k](e.v)};Z("f","a,b");
